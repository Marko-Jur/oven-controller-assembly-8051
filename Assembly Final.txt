;----------------;
; INITIALIZATION ;
;----------------;


; PLEASE READ:													
; While the program itself is identical to the final submitted version on Canvas, comments and format have been changed for readability. 


$NOLIST
$MOD9351
$LIST


CLK         EQU 14746000  ; Microcontroller system clock frequency in Hz
CCU_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))


XTAL 		EQU 7373000
BAUD        EQU 115200
NEWBRVAL    EQU ((CLK/BAUD)-16)
BRVAL 		EQU ((XTAL/BAUD)-16)


; OUR PINS ;


SSRpin 		EQU P2.7
FLASH_CE    EQU P2.4
SOUND       EQU P2.1


; Commands supported by the SPI flash memory according to the datasheet
WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite


; OUR PINS ;
	CSEG
org 0x0000 ; Reset vector
    ljmp MainProgram


org 0x0003 ; External interrupt 0 vector (not used in this code)
	reti


org 0x000B ; Timer/Counter 0 overflow interrupt vector (not used in this code)
	reti


org 0x0013 ; External interrupt 1 vector (not used in this code)
	reti


org 0x001B ; Timer/Counter 1 overflow interrupt vector (not used in this code
	reti


org 0x0023 ; Serial port receive/transmit interrupt vector (not used in this code)
	reti


org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
	ljmp CCU_ISR


bseg
PB0: dbit 1 ; Variable to store the state of pushbutton 0 after calling ADC_to_PB below
PB1: dbit 1 ; Variable to store the state of pushbutton 1 after calling ADC_to_PB below
PB2: dbit 1 ; Variable to store the state of pushbutton 2 after calling ADC_to_PB below
PB3: dbit 1 ; Variable to store the state of pushbutton 3 after calling ADC_to_PB below
PB4: dbit 1 ; Variable to store the state of pushbutton 4 after calling ADC_to_PB below
PB5: dbit 1 ; Variable to store the state of pushbutton 5 after calling ADC_to_PB below
PB6: dbit 1 ; Variable to store the state of pushbutton 6 after calling ADC_to_PB below
mf: dbit 1
dog: dbit 1 ; 
statechangeflag: dbit 1


dseg at 0x30


; OVEN CONTROL VARIABLES:


time: ds 2
timesoak: ds 2
tempsoak: ds 2
timereflow: ds 2
tempreflow: ds 2
Result: ds 2
soaktimer: ds 2
reflowtimer: ds 2
x: ds 4
y: ds 4
bcd: ds 5


cat: ds  4 ; represents oven temp
sheep: ds 4 ; represent reference temp


; VARIABLES FOR USE BY THE SPEAKER:


soakramptimer: ds 2 ; Used to keep time in the whole circuit for the speaker - initially used for soakramp, hence the name
reflowramptimer:  ds 2 ; This timer was not used in the final implementation


statecounter: ds 1 
instruction: ds 1
hundredsj: ds 1
tensj: ds 1
unitsj: ds 1
unitsresult: ds 1
tensresult: ds 1
hundredsresult: ds 1
cooltimer: ds 1


temp: ds 1
speak_num:	ds 1
tmp_count:	ds 1
last: ds 1


; VARIABLES FOR TESTING:


other_dog: ds 2 ; this variable is not used in the current iteration of the code


; GUI AND SPEAKER INTEGRATION VARIABLES:


w:   ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
somecounter: ds 1
textvar: ds 4
		
cseg


; These 'equ' must match the wiring between the microcontroller and the LCD!
LCD_RS equ P0.5
LCD_RW equ P0.6
LCD_E  equ P0.7
LCD_D4 equ P1.2
LCD_D5 equ P1.3
LCD_D6 equ P1.4
LCD_D7 equ P1.6


$NOLIST
$include(LCD_4bit_LPC9351.inc) ; A library of LCD related functions and utility macros
$include(math32.inc)
$LIST


;---------------------------------;
; Routine to initialize the CCU.  ;
; We are using the CCU timer in a ;
; manner similar to the timer 2   ;
; available in other 8051s        ;
;---------------------------------;


CCU_Init:
	mov TH2, #high(CCU_RELOAD)
	mov TL2, #low(CCU_RELOAD)
	mov TOR2H, #high(CCU_RELOAD)
	mov TOR2L, #low(CCU_RELOAD)
	mov TCR21, #10000000b ; Latch the reload value
	mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
	setb ECCU ; Enable CCU interrupt
	setb TMOD20 ; Start CCU timer
	ret


;---------------------------------;
; ISR for CCU.  Used to playback  ;
; the WAV file stored in the SPI  ;
; flash memory.                   ;
;---------------------------------;


CCU_ISR:
	mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
	setb P2.6 ; To check the interrupt rate with oscilloscope.
	
	; The registers used in the ISR must be saved in the stack
	push acc
	push psw
	
	; Check if the play counter is zero.  If so, stop playing sound.
	mov a, w+0
	orl a, w+1
	orl a, w+2
	jz stop_playing
	
	; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
	mov a, #0xff
	dec w+0
	cjne a, w+0, keep_playing
	dec w+1
	cjne a, w+1, keep_playing
	dec w+2
	
keep_playing:


	lcall Send_SPI ; Read the next byte from the SPI Flash...
	mov AD1DAT3, a ; and send it to the DAC
	
	sjmp CCU_ISR_Done


stop_playing:
	clr TMOD20 ; Stop CCU timer
	setb FLASH_CE  ; Disable SPI Flash
	clr SOUND ; Turn speaker off


CCU_ISR_Done:	
	pop psw
	pop acc
	clr P2.6
	reti


putchar:
	jbc	TI,putchar_L1
	sjmp putchar
putchar_L1:
	mov	SBUF,a
	ret
	
getchar:
	jbc	RI,getchar_L1
	sjmp getchar
getchar_L1:
	mov	a,SBUF
	ret


Wait1S:
	mov R2, #40
M3:	mov R1, #250
M2:	mov R0, #184
M1:	djnz R0, M1 ; 2 machine cycles-> 2*0.27126us*184=100us
	djnz R1, M2 ; 100us*250=0.025s
	djnz R2, M3 ; 0.025s*40=1s
	ret
	
Wait200mS:
	mov R2, #8
M7:	mov R1, #250
M6:	mov R0, #184
M5:	djnz R0, M5 ; 2 machine cycles-> 2*0.27126us*184=100us
	djnz R1, M6 ; 100us*250=0.025s
	djnz R2, M7 ; 0.025s*40=1s
	ret
	
Wait10mS:


	mov R0, #184
M4:	djnz R0, M4 ; 2 machine cycles-> 2*0.27126us*184=100us
	ret


InitSerialPort:
    
	mov	BRGCON,#0x00
	mov	BRGR1,#high(BRVAL)
	mov	BRGR0,#low(BRVAL)
	mov	BRGCON,#0x03 ; Turn-on the baud rate generator
	mov	SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
	anl	P1M1,#11111100B
	anl	P1M2,#11111100B
	ret
	
DoubleInitSerialPort:
    
	mov	BRGCON,#0x00
	mov	BRGR1,#high(NEWBRVAL)
	mov	BRGR0,#low(NEWBRVAL)
	mov	BRGCON,#0x03 ; Turn-on the baud rate generator
	mov	SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
	anl	P1M1,#11111100B
	anl	P1M2,#11111100B
	ret
	
;---------------------------------;
; Initialize ADC1/DAC1 as DAC1.   ;
; Warning, the ADC1/DAC1 can work ;
; only as ADC or DAC, not both.   ;
; The P89LPC9351 has two ADC/DAC  ;
; interfaces.  One can be used as ;
; ADC and the other can be used   ;
; as DAC.  Also configures the    ;
; pin associated with the DAC, in ;
; this case P0.4 as 'Open Drain'. ;
;---------------------------------;


InitDAC1:
    ; Configure pin P0.4 (DAC1 output pin) as open drain
	orl	P0M1,   #00010000B
	orl	P0M2,   #00010000B
    mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
	mov	ADCON1, #00000100B ; Enable the converter
	mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
	ret


;---------------------------------;
; Initialize ADC0/DAC0 as ADC0.   ;
;---------------------------------;


InitADC0:
	; ADC0_0 is connected to P1.7
	; ADC0_1 is connected to P0.0
	; ADC0_2 is connected to P2.1
	; ADC0_3 is connected to P2.0
    ; Configure pins P1.7, P0.0, P2.1, and P2.0 as inputs
    orl P0M1, #00000001b
    anl P0M2, #11111110b
    orl P1M1, #10000000b
    anl P1M2, #01111111b
    orl P2M1, #00000011b
    anl P2M2, #11111100b
	; Setup ADC0
	setb BURST0 ; Autoscan continuos conversion mode
	mov	ADMODB,#0x20 ;ADC0 clock is 7.3728MHz/2
	mov	ADINS,#0x0f ; Select the four channels of ADC0 for conversion
	mov	ADCON0,#0x05 ; Enable the converter and start immediately
	; Wait for first conversion to complete
InitADC0_L1:
	mov	a,ADCON0
	jnb	acc.3,InitADC0_L1
	ret
;---------------------------------;
; Change the internal RC osc. clk ;
; from 7.373MHz to 14.746MHz.     ;
;---------------------------------;


Double_Clk:
    mov dptr, #CLKCON
    movx a, @dptr
    orl a, #00001000B ; double the clock speed to 14.746MHz
    movx @dptr,a
	ret
	
Single_Clk:
    mov dptr, #CLKCON
    movx a, @dptr
    anl a, #11110111B ; double the clock speed to 14.746MHz
    movx @dptr,a
    ret
    
;---------------------------------;
; Initialize the SPI interface    ;
; and the pins associated to SPI. ;
;---------------------------------;


Init_SPI:
	; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
	anl P2M1, #low(not(00110100B))
	orl P2M2, #00110100B
	; Configure MISO (P2.3) as input (see table 42, page 51)
	orl P2M1, #00001000B
	anl P2M2, #low(not(00001000B)) 
	; Configure SPI
	mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
	ret


;---------------------------------;
; Sends AND receives a byte via   ;
; SPI.                            ;
;---------------------------------;


Send_SPI:
	mov SPDAT, a
Send_SPI_1:
	mov a, SPSTAT 
	jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
	mov SPSTAT, a ; Clear SPI Transfer Completion Flag
	mov a, SPDAT ; return received byte via accumulator
	ret


;---------------------------------;
; SPI flash 'write enable'        ;
; instruction.                    ;
;---------------------------------;


Enable_Write:
	clr FLASH_CE
	mov a, #WRITE_ENABLE
	lcall Send_SPI
	setb FLASH_CE
	ret


;---------------------------------;
; This function checks the 'write ;
; in progress' bit of the SPI     ;
; flash memory.                   ;
;---------------------------------;


Check_WIP:
	clr FLASH_CE
	mov a, #READ_STATUS
	lcall Send_SPI
	mov a, #0x55
	lcall Send_SPI
	setb FLASH_CE
	jb acc.0, Check_WIP ;  Check the Write in Progress bit
	ret
	
;---------------------------------;
; CRC-CCITT (XModem) Polynomial:  ;
; x^16 + x^12 + x^5 + 1 (0x1021)  ;
; CRC in [R7,R6].                 ;
; Converted to a macro to remove  ;
; the overhead of 'lcall' and     ;
; 'ret' instructions, since this  ;
; 'routine' may be executed over  ;
; 4 million times!                ;
;---------------------------------;
;crc16:


crc16 mac
	xrl	a, r7			; XOR high of CRC with byte
	mov r0, a			; Save for later use
	mov	dptr, #CRC16_TH ; dptr points to table high
	movc a, @a+dptr		; Get high part from table
	xrl	a, r6			; XOR With low byte of CRC
	mov	r7, a			; Store to high byte of CRC
	mov a, r0			; Retrieve saved accumulator
	mov	dptr, #CRC16_TL	; dptr points to table low	
	movc a, @a+dptr		; Get Low from table
	mov	r6, a			; Store to low byte of CRC
	;ret
endmac


;---------------------------------;
; High constants for CRC-CCITT    ;
; (XModem) Polynomial:            ;
; x^16 + x^12 + x^5 + 1 (0x1021)  ;
;---------------------------------;


CRC16_TH:
	db	000h, 010h, 020h, 030h, 040h, 050h, 060h, 070h
	db	081h, 091h, 0A1h, 0B1h, 0C1h, 0D1h, 0E1h, 0F1h
	db	012h, 002h, 032h, 022h, 052h, 042h, 072h, 062h
	db	093h, 083h, 0B3h, 0A3h, 0D3h, 0C3h, 0F3h, 0E3h
	db	024h, 034h, 004h, 014h, 064h, 074h, 044h, 054h
	db	0A5h, 0B5h, 085h, 095h, 0E5h, 0F5h, 0C5h, 0D5h
	db	036h, 026h, 016h, 006h, 076h, 066h, 056h, 046h
	db	0B7h, 0A7h, 097h, 087h, 0F7h, 0E7h, 0D7h, 0C7h
	db	048h, 058h, 068h, 078h, 008h, 018h, 028h, 038h
	db	0C9h, 0D9h, 0E9h, 0F9h, 089h, 099h, 0A9h, 0B9h
	db	05Ah, 04Ah, 07Ah, 06Ah, 01Ah, 00Ah, 03Ah, 02Ah
	db	0DBh, 0CBh, 0FBh, 0EBh, 09Bh, 08Bh, 0BBh, 0ABh
	db	06Ch, 07Ch, 04Ch, 05Ch, 02Ch, 03Ch, 00Ch, 01Ch
	db	0EDh, 0FDh, 0CDh, 0DDh, 0ADh, 0BDh, 08Dh, 09Dh
	db	07Eh, 06Eh, 05Eh, 04Eh, 03Eh, 02Eh, 01Eh, 00Eh
	db	0FFh, 0EFh, 0DFh, 0CFh, 0BFh, 0AFh, 09Fh, 08Fh
	db	091h, 081h, 0B1h, 0A1h, 0D1h, 0C1h, 0F1h, 0E1h
	db	010h, 000h, 030h, 020h, 050h, 040h, 070h, 060h
	db	083h, 093h, 0A3h, 0B3h, 0C3h, 0D3h, 0E3h, 0F3h
	db	002h, 012h, 022h, 032h, 042h, 052h, 062h, 072h
	db	0B5h, 0A5h, 095h, 085h, 0F5h, 0E5h, 0D5h, 0C5h
	db	034h, 024h, 014h, 004h, 074h, 064h, 054h, 044h
	db	0A7h, 0B7h, 087h, 097h, 0E7h, 0F7h, 0C7h, 0D7h
	db	026h, 036h, 006h, 016h, 066h, 076h, 046h, 056h
	db	0D9h, 0C9h, 0F9h, 0E9h, 099h, 089h, 0B9h, 0A9h
	db	058h, 048h, 078h, 068h, 018h, 008h, 038h, 028h
	db	0CBh, 0DBh, 0EBh, 0FBh, 08Bh, 09Bh, 0ABh, 0BBh
	db	04Ah, 05Ah, 06Ah, 07Ah, 00Ah, 01Ah, 02Ah, 03Ah
	db	0FDh, 0EDh, 0DDh, 0CDh, 0BDh, 0ADh, 09Dh, 08Dh
	db	07Ch, 06Ch, 05Ch, 04Ch, 03Ch, 02Ch, 01Ch, 00Ch
	db	0EFh, 0FFh, 0CFh, 0DFh, 0AFh, 0BFh, 08Fh, 09Fh
	db	06Eh, 07Eh, 04Eh, 05Eh, 02Eh, 03Eh, 00Eh, 01Eh


;---------------------------------;
; Low constants for CRC-CCITT     ;
; (XModem) Polynomial:            ;
; x^16 + x^12 + x^5 + 1 (0x1021)  ;
;---------------------------------;


CRC16_TL:
	db	000h, 021h, 042h, 063h, 084h, 0A5h, 0C6h, 0E7h
	db	008h, 029h, 04Ah, 06Bh, 08Ch, 0ADh, 0CEh, 0EFh
	db	031h, 010h, 073h, 052h, 0B5h, 094h, 0F7h, 0D6h
	db	039h, 018h, 07Bh, 05Ah, 0BDh, 09Ch, 0FFh, 0DEh
	db	062h, 043h, 020h, 001h, 0E6h, 0C7h, 0A4h, 085h
	db	06Ah, 04Bh, 028h, 009h, 0EEh, 0CFh, 0ACh, 08Dh
	db	053h, 072h, 011h, 030h, 0D7h, 0F6h, 095h, 0B4h
	db	05Bh, 07Ah, 019h, 038h, 0DFh, 0FEh, 09Dh, 0BCh
	db	0C4h, 0E5h, 086h, 0A7h, 040h, 061h, 002h, 023h
	db	0CCh, 0EDh, 08Eh, 0AFh, 048h, 069h, 00Ah, 02Bh
	db	0F5h, 0D4h, 0B7h, 096h, 071h, 050h, 033h, 012h
	db	0FDh, 0DCh, 0BFh, 09Eh, 079h, 058h, 03Bh, 01Ah
	db	0A6h, 087h, 0E4h, 0C5h, 022h, 003h, 060h, 041h
	db	0AEh, 08Fh, 0ECh, 0CDh, 02Ah, 00Bh, 068h, 049h
	db	097h, 0B6h, 0D5h, 0F4h, 013h, 032h, 051h, 070h
	db	09Fh, 0BEh, 0DDh, 0FCh, 01Bh, 03Ah, 059h, 078h
	db	088h, 0A9h, 0CAh, 0EBh, 00Ch, 02Dh, 04Eh, 06Fh
	db	080h, 0A1h, 0C2h, 0E3h, 004h, 025h, 046h, 067h
	db	0B9h, 098h, 0FBh, 0DAh, 03Dh, 01Ch, 07Fh, 05Eh
	db	0B1h, 090h, 0F3h, 0D2h, 035h, 014h, 077h, 056h
	db	0EAh, 0CBh, 0A8h, 089h, 06Eh, 04Fh, 02Ch, 00Dh
	db	0E2h, 0C3h, 0A0h, 081h, 066h, 047h, 024h, 005h
	db	0DBh, 0FAh, 099h, 0B8h, 05Fh, 07Eh, 01Dh, 03Ch
	db	0D3h, 0F2h, 091h, 0B0h, 057h, 076h, 015h, 034h
	db	04Ch, 06Dh, 00Eh, 02Fh, 0C8h, 0E9h, 08Ah, 0ABh
	db	044h, 065h, 006h, 027h, 0C0h, 0E1h, 082h, 0A3h
	db	07Dh, 05Ch, 03Fh, 01Eh, 0F9h, 0D8h, 0BBh, 09Ah
	db	075h, 054h, 037h, 016h, 0F1h, 0D0h, 0B3h, 092h
	db	02Eh, 00Fh, 06Ch, 04Dh, 0AAh, 08Bh, 0E8h, 0C9h
	db	026h, 007h, 064h, 045h, 0A2h, 083h, 0E0h, 0C1h
	db	01Fh, 03Eh, 05Dh, 07Ch, 09Bh, 0BAh, 0D9h, 0F8h
	db	017h, 036h, 055h, 074h, 093h, 0B2h, 0D1h, 0F0h


sound_index:
    db 0x00, 0x0d, 0x50 ; 0 
    db 0x00, 0xbb, 0x53 ; 1
    db 0x01, 0x3c, 0x1c ; 2
    db 0x01, 0x9f, 0x96 ; 3
    db 0x02, 0x2d, 0xd9 ; 4
    db 0x02, 0x99, 0xe6 ; 5
    db 0x03, 0x20, 0xe6 ; 6
    db 0x03, 0xa0, 0xe6 ; 7
    db 0x04, 0x10, 0x09 ; 8 
    db 0x04, 0x7c, 0x62 ; 9
    db 0x04, 0xfd, 0x5d ; 10
	db 0x05, 0x70, 0x00 ; 11
    db 0x05, 0xcc, 0x5d ; 12 
    db 0x06, 0x65, 0x11 ; 13
    db 0x06, 0xc2, 0xa6 ; 14 
    db 0x07, 0x4a, 0xd2 ; 15
    db 0x07, 0xc8, 0xd2 ; 16
    db 0x08, 0x67, 0xc8 ; 17
    db 0x08, 0xe3, 0xfe ; 18 
    db 0x09, 0x71, 0x4a ; 19
    db 0x09, 0xf5, 0x1b ; 20
    db 0x0a, 0x60, 0xe4 ; 30 (21)
    db 0x0a, 0xdf, 0xc4 ; 40 (22)
    db 0x0b, 0x55, 0xbb ; 50 (23)
    db 0x0b, 0xdc, 0xb7 ; 60 (24)
    db 0x0c, 0x5d, 0xe0 ; 70 (25)
    db 0x0c, 0xdd, 0x05 ; 80 (26)
    db 0x0d, 0x5e, 0x12 ; 90 (27)
    db 0x0e, 0x55, 0xc4 ; Welcome to the oven (28)
    db 0x0f, 0xdd, 0x00 ; Heating Oven (29)
    db 0x10, 0x22, 0xd7 ; Beginning Soak (30)
    db 0x11, 0x22, 0x9d ; Beginning Reflow (31)
    db 0x11, 0xa0, 0x81 ; Reflow Complete (32)
    db 0x12, 0x4c, 0x17 ; Soldering Complete (33)
    db 0x13, 0xcc, 0x43 ; one hundred (34)
    db 0x14, 0x77, 0x04 ; two hundreds (35)
   
; Size of each sound in 'sound_index'
size_length:
    db 0x00, 0x00, 0x00 ; 0 
    db 0x00, 0x45, 0x13 ; 1 
    db 0x00, 0x33, 0x02 ; 2
    db 0x00, 0x35, 0x43 ; 3
    db 0x00, 0x45, 0x43 ; 4
    db 0x00, 0x4f, 0x23 ; 5
    db 0x00, 0x4f, 0x23 ; 6
    db 0x00, 0x42, 0x59 ; 7  
    db 0x00, 0x42, 0x59 ; 8 
    db 0x00, 0x4e, 0x94 ; 9 
    db 0x00, 0x32, 0x67 ; 10
    db 0x00, 0x48, 0x0c ; 11 
    db 0x00, 0x48, 0x0c ; 12
    db 0x00, 0x60, 0xa8 ; 13
    db 0x00, 0x6d, 0x95 ; 14
    db 0x00, 0x5c, 0x2c ; 15 
    db 0x00, 0x61, 0xe7 ; 16 
    db 0x00, 0x60, 0x0f ; 17
    db 0x00, 0x60, 0x0f ; 18
 	db 0x00, 0x60, 0x0f ; 19
    db 0x00, 0x60, 0x0f ; 20
    db 0x00, 0x55, 0x0f ; 30 (21)
    db 0x00, 0x4d, 0xbb ; 40 (22)
    db 0x00, 0x7e, 0x3b ; 50 (23)
    db 0x00, 0x70, 0xe0 ; 60 (24)
    db 0x00, 0x60, 0xf7 ; 70 (25)
   	db 0x00, 0x50, 0xf7 ; 80 (26)
    db 0x00, 0x44, 0x0d ; 90 (27) 
    db 0x00, 0xaa, 0x67 ; Welcome to the oven (28) 0
    db 0x00, 0x77, 0x67 ; Heating Oven (29) 1
    db 0x00, 0xbb, 0x72 ; Beginnig Soak (30) 2
    db 0x00, 0x88, 0x73 ; Beginning Reflow (31) 3
    db 0x00, 0xbb, 0x3a ; Reflow Complete (32) 4
    db 0x00, 0xa8, 0x66 ; Soldering Complete (33) 5 
    db 0x00, 0x50, 0xd1 ; One hundred (34)
    db 0x00, 0x4d, 0x96 ; Two hundreds (35)
	
HexAscii: db '0123456789ABCDEF'


SendTemp:
	mov dptr, #HexAscii 
	
	mov a, bcd+1
	swap a
	anl a, #0xf
	movc a, @a+dptr
	lcall putchar
	mov a, bcd+1
	anl a, #0xf
	movc a, @a+dptr
	lcall putchar
	mov a, bcd+0
	swap a
	anl a, #0xf
	movc a, @a+dptr
	lcall putchar
	mov a, bcd+0
	anl a, #0xf
	movc a, @a+dptr
	lcall putchar	
	ret
	
SendHex:
	mov a, #'0'
	lcall putchar
	mov a, #'x'
	lcall putchar
	mov dptr, #HexAscii 
	mov a, b
	swap a
	anl a, #0xf
	movc a, @a+dptr
	lcall putchar
	mov a, b
	anl a, #0xf
	movc a, @a+dptr
	lcall putchar
	mov a, #' '
	lcall putchar
	ret
	
SendString:
    clr a
    movc a, @a+dptr
    jz SendString_L1
    lcall putchar
    inc dptr
    sjmp SendString  
SendString_L1:
	ret
	
ADC_to_PB:
	setb PB6
	setb PB5
	setb PB4
	setb PB3
	setb PB2
	setb PB1
	setb PB0
	; Check PB6
	clr c
	mov a, AD0DAT1
	subb a, #(206-10) ; 2.8V=216*(3.3/255); the -10 is to prevent false readings
	jc ADC_to_PB_L6
	clr PB6
	ret
ADC_to_PB_L6:
	; Check PB5
	clr c
	mov a, AD0DAT1
	subb a, #(185-10) ; 2.4V=185*(3.3/255); the -10 is to prevent false readings
	jc ADC_to_PB_L5
	clr PB5
	ret
ADC_to_PB_L5:
	; Check PB4
	clr c
	mov a, AD0DAT1
	subb a, #(154-10) ; 2.0V=154*(3.3/255); the -10 is to prevent false readings
	jc ADC_to_PB_L4
	clr PB4
	ret
ADC_to_PB_L4:
	; Check PB3
	clr c
	mov a, AD0DAT1
	subb a, #(123-10) ; 1.6V=123*(3.3/255); the -10 is to prevent false readings
	jc ADC_to_PB_L3
	clr PB3
	ret
ADC_to_PB_L3:
	; Check PB2
	clr c
	mov a, AD0DAT1
	subb a, #(92-10) ; 1.2V=92*(3.3/255); the -10 is to prevent false readings
	jc ADC_to_PB_L2
	clr PB2
	ret
ADC_to_PB_L2:
	; Check PB1
	clr c
	mov a, AD0DAT1
	subb a, #(61-10) ; 0.8V=61*(3.3/255); the -10 is to prevent false readings
	jc ADC_to_PB_L1
	clr PB1
	ret
ADC_to_PB_L1:
	; Check PB1
	clr c
	mov a, AD0DAT1
	subb a, #(30-10) ; 0.4V=30*(3.3/255); the -10 is to prevent false readings
	jc ADC_to_PB_L0
	clr PB0
	ret
ADC_to_PB_L0:
	; No pusbutton pressed	
	ret


;-----------;
; FUNCTIONS ;
;-----------;


; SEND_BCD ;


Send_BCD mac
	push ar0
	mov r0, %0
	lcall ?Send_BCD
	pop ar0
endmac


?Send_BCD:
	push acc
	; Write most sig digit
	mov a, r0
	swap a
	anl a, #0fh
	orl a, #30h
	lcall putchar
	; Write least sig digit
	mov a, r0
	anl a, #0fh
	orl a, #30h
	lcall putchar
	pop acc
	ret
	
; Set_Value:
; Sets a particular reflow parameter based on the user's input


; Inputs: 
; PB0: hundreds
; PB1: tens
; PB2: units
; PB4: clear
; PB5: cycle back through program
; PB6: cycle forward through program
		
Set_Value:


	mov r2, #0
	
Set_Value_loop:


	mov a, #'\r' ; move cursor all the way to the left
   	lcall putchar
	
	mov a, r2
	
	mov x, a
	mov x+1, #0
	mov x+2, #0
	mov x+3, #0
	
	lcall hex2bcd
	Send_BCD(bcd+1)
	Send_BCD(bcd)
	
	Set_Cursor(2,1) ; (1,2)
	
	Display_BCD(bcd+1)
	Display_BCD(bcd)


	lcall ADC_to_PB
	
			jb PB0, tens_check ; hundreds check - if hundreds button pressed, add 100 to r2
		
			mov a, somecounter
			add a, #1
			mov somecounter, a
			
			cjne a, #3, add_hundred
			
			mov r2, #0
			mov somecounter, #0
			
			sjmp hundredsloop
	
			add_hundred:
			mov a, r2
			add a, #0x64
			mov r2, a
		
					hundredsloop: ; for bounce
					lcall ADC_to_PB
					jnb PB0, hundredsloop
	
		tens_check:
		
			lcall ADC_to_PB
			jb PB1, units_check ; tens check - if tens button pressed, add 10 to r2
			
			mov a, r2
			add a, #0xA
			mov r2, a
	
					tensloop: ; for bounce
					lcall ADC_to_PB
					jnb PB1, tensloop
	
		units_check:
		
			lcall ADC_to_PB
			jb PB2, buttoncheck ; units check - if units button pressed, add 1 to r2
			
			mov a, r2
			add a, #0x1
			mov r2, a
			
			mov a, r0
			add a, #0x1
			mov r0, a
		
					unitsloop: ; for bounce
					lcall ADC_to_PB
					jnb PB2, unitsloop


	buttoncheck: ; if any of these buttons are pressed, return to the original function
		lcall ADC_to_PB
		jnb PB4, GOHOME
		jnb PB5, GOHOME
		jnb PB6, GOHOME
	
	retval:	ljmp Set_Value_loop
	
	GOHOME: ret


; Wait 10us


Wait10us:
    mov R0, #18
    djnz R0, $ ; 2 machine cycles-> 2*0.27126us*18=10us
	ret
	
;----------;
; Messages ;
;----------;


Title: db 'Oven Controller!\r\n', 0
TimeSoakMessage: db 'Enter soak time: \r\n', 0
TempSoakMessage: db 'Enter soak temp: \r\n', 0
TimeReflowMessage: db 'Enter reflow time: \r\n', 0
TempReflowMessage: db 'Enter reflow temp: \r\n', 0
Blank: db '      ',0
Weback: db 'We are back\r\n', 0
forwardsuccess: db 'Onward!\n', 0
backwardsuccess: db 'Backward!\r\n', 0
Success: db 'We made it\r\n', 0
Blank1: db '                ', 0
Blank2: db '                ', 0
Welcome: db 'Welcome!', 0
StartingOven: db 'Starting Oven', 0
EnteringSoak: db 'Entering soak', 0 ; 0vvvvv
EnteringReflow: db 'Entering reflow', 0
SolderingComplete: db 'Soldering complete', 0
ReflowComplete: db 'Reflow complete', 0
	
MainProgram:
    mov SP, #0x7F
    
;---------------------------------;
; Initial configuration of ports. ;
; After reset the default for the ;
; pins is 'Open Drain'.  This     ;
; routine changes them pins to    ;
; Quasi-bidirectional like in the ;
; original 8051.                  ;
; Notice that P1.2 and P1.3 are   ;
; always 'Open Drain'. If those   ;
; pins are to be used as output   ;
; they need a pull-up resistor.   ;
;---------------------------------;


    mov P0M1, #00H
    mov P0M2, #00H
    mov P1M1, #00H
    mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1kohm pull-up resistors!
    mov P2M1, #00H
    mov P2M2, #00H
    mov P3M1, #00H
    mov P3M2, #00H
   	
 	lcall InitADC0
    lcall InitDAC1 ; Call after 'Ports_Init'
	lcall CCU_Init
	lcall Init_SPI
	lcall LCD_4bit
	
	setb EA ; Enable global interrupts.
	
;--------------------------------------------;
;			    Input program				 ;
;--------------------------------------------;


;  1. Main menu
;  2. Soak time input mode
;  3. Soak temperature input mode
;  4. Reflow time input mode
;  5. Reflow temperature input mode
;  6. Wait for user to hit start 


start:


	mov timesoak, #0 ; initialize all reflow parameter variables to 0
	mov tempsoak, #0
	mov timereflow, #0
	mov tempreflow, #0
	
	clr SSRpin
	
	lcall DoubleInitSerialPort
    lcall Double_Clk
    
    ; Speaker state #1: "Welcome to the oven!"
	
	mov instruction, #2
	mov statecounter, #0
	lcall speak
	mov instruction, #0
	
	mov somecounter, #0
	
	Set_Cursor(1,1)
	Send_Constant_String(#Welcome)
	
	lcall Wait1s
	lcall Wait1s
	lcall Wait1s
	
	lcall InitSerialPort
    lcall Single_Clk
	
	sjmp mainmenu
	
SoaktimeB: ; for bounce
lcall ADC_to_PB
jnb PB4, SoaktimeB 


; 1. Main menu


mainmenu:
	mov a, #'\r' ; move cursor all the way to the left
    lcall putchar
   
   	mov a, #'\n' ; move cursor all the way to the left
    lcall putchar
    
	mov dptr, #Title
	lcall SendString


mainmenu2:
	lcall ADC_to_PB
	jnb PB6, mainmenuwaitloop ; jumps to soak time input if forward is pressed 
	sjmp mainmenu2


mainmenuwaitloop:
lcall ADC_to_PB
jnb PB6, mainmenuwaitloop


lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms


; 2. Soak time input mode


SoakTempB:
lcall ADC_to_PB
jnb PB4, SoakTempB


soaktime:
    
    mov a, #'\r' ; move cursor all the way to the left
    lcall putchar


	mov DPTR, #TimeSoakMessage
	lcall SendString
	
	Set_Cursor(1,1)
	Send_Constant_String(#TimeSoakMessage)


	lcall Set_Value
	mov timesoak, r2
	
	mov a, #'\n' ; move cursor all the way to the left
    lcall putchar
    


soaktimeforward: jnb PB6, SoakTimeA ; next routine
	
back1:
	jnb PB4, SoakTimeBinter ; goes back to main menu
	sjmp soaktimeclear
	SoakTimeBinter:  ljmp SoakTimeB
	
soaktimeclear:
	jnb PB5, SoakTimeC
	ljmp soaktime
	
	SoakTimeC:
	lcall ADC_to_PB
	jnb PB5, SoakTimeC
	
	mov timesoak, #0
	ljmp soaktime	
	
; 3. Soak temperature input mode


SoakTimeA:
lcall ADC_to_PB
jnb PB6, SoaktimeA


lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms
lcall Wait10ms


ReflowTimeB:
lcall ADC_to_PB
jnb PB4, ReflowTimeB
	
soaktemp:


	mov a, #'\r' ; move cursor all the way to the left
    lcall putchar
    
	mov dptr, #TempSoakMessage
	lcall SendString
	
	Set_Cursor(1,1)
	Send_Constant_String(#TempSoakMessage)
	
	lcall Set_Value
	mov tempsoak, r2
	
	mov a, #'\n' ; move cursor all the way to the left
    lcall putchar
    
soaktempforward: jnb PB6, SoakTempA ; next routine
	
back2: jnb PB4, back2inter ; goes back to soak time


sjmp soaktempclear


back2inter: ljmp SoakTempB


soaktempclear:
	jnb PB5, SoakTempC
	ljmp soaktemp
	
	SoakTempC:
	lcall ADC_to_PB
	jnb PB5, SoakTempC
	
	mov timesoak, #0
	ljmp soaktemp	
		
;  4. Reflow time input mode


SoakTempA:
lcall ADC_to_PB
jnb PB6, SoakTempA


ReflowTempB:
lcall ADC_to_PB
jnb PB4, ReflowTempB


reflowtime:
	mov a, #'\r' ; move cursor all the way to the left
    lcall putchar


	mov dptr, #TimeReflowMessage
	lcall SendString
	
	Set_Cursor(1,1)
	Send_Constant_String(#TimeReflowMessage)


	lcall Set_Value
	mov timereflow, r2
	
	mov a, #'\n' ; move cursor all the way to the left
    lcall putchar
    	
reflowtimeforward: jnb PB6, ReflowTimeA ; next routine
	
back3: jnb PB4, ReflowTimeBinter ; goes back to soak time
sjmp reflowtimeclear
ReflowTimeBinter: ljmp ReflowTimeB


reflowtimeclear:
	jnb PB5, ReflowTimeC
	ljmp reflowtime
	
	ReflowTimeC:
	lcall ADC_to_PB
	jnb PB5, ReflowTimeC
	
	mov timereflow, #0
	ljmp reflowtime	
	
; Reflow temp input mode


ReflowTimeA:
lcall ADC_to_PB
jnb PB6, ReflowTimeA


Waitreturn:
lcall ADC_to_PB
jnb PB4, Waitreturn


reflowtemp:	
	mov a, #'\r' ; move cursor all the way to the left
    lcall putchar


	mov dptr, #TempReflowMessage
	lcall SendString
	
	Set_Cursor(1,1)
	Send_Constant_String(#TempReflowMessage)
	
	lcall Set_Value
	mov tempreflow, r2
	
	mov a, #'\n' ; move cursor all the way to the left
    lcall putchar
    
reflowtempforward: jnb PB6, ReflowTempA ; next routine
	
back4: jnb PB4, ReflowTempBinter ; goes back to soak time
sjmp reflowtempclear
ReflowTempBinter: ljmp ReflowTempB


reflowtempclear:
	jnb PB5, ReflowTempC
	ljmp reflowtemp
	
	ReflowTempC:
	lcall ADC_to_PB
	jnb PB5, ReflowTempC
	
	mov tempreflow, #0
	ljmp reflowtemp
	
; 5. Wait for user to hit start


ReflowTempA:
lcall ADC_to_PB
jnb PB6, ReflowTempA


mov a, #'\r' ; move cursor all the way to the left
lcall putchar
 
mov dptr, #Success
lcall SendString


mov a, #'\n' ; move cursor all the way to the left
lcall putchar


wait: 
lcall ADC_to_PB
jnb PB4, Waitreturn
jnb PB6, startoven 


	mov a, #'\r' ; move cursor all the way to the left
	lcall putchar


sjmp wait	
	
;------------;
; START OVEN ;
;------------;


; Algorithm:


; At this point, input values have been set, available in variables:
; timesoak, tempsoak, timereflow, tempreflow
; Step 1: Switch on SSR, switching on oven
; Step 2: Check 1 - if tempsoak achieved:
	; a: Switch off SSR
	; b: Switch on soaktimer
; Step 3: 
	; Check 2.1 - if soaktimer = timesoak, switch on oven and don't switch off
	; Check 2.2 - if oven temp < tempsoak - 3 degrees, switch on oven / else if oven temp > tempsoak + 3 degrees, switch off oven / else, chill
; Step 4: Check 3 - if tempreflow achieved:
	; a. Switch off SSR
	; b. switch on reflowtimer
; Step 5: 
	; Check 4.1  - if reflowtimer = timereflow, switch on oven and don't switch off
	; Check 4.2 - if oven temp < reflowtemp - 3 degrees, switch on oven / else if oven temp > reflowtemp + 3 degrees, switch off oven/ else, chill
	
; NOTES: 
; 1. 'theoatmeal' refers to a state that is 'just right'. In an earlier version of the code, this was the plateau stage. It now refers to
; the transition stage immediately before the reflow ramp begins.  
; 2. 'Result' is the temperature input from the oven, updated in the readtemperature code.


startoven:
	
; Step 1: Switch on SSR, switching on oven


	lcall Double_Clk
	lcall DoubleInitSerialPort
	
	clr a
	setb SSRpin 
	
	mov soaktimer, #0
	mov reflowtimer, #0
	mov soakramptimer, #0
	mov time, #0
	
	mov statecounter, #1
	setb statechangeflag
	
	Set_Cursor(1,1)
	Send_Constant_String(#Blank1)
	
	Set_Cursor(2,1)
	Send_Constant_String(#Blank2)
	
	Set_Cursor(1,1)
	Send_Constant_String(#StartingOven)
	
; Step 2: Check 1 - if Result > tempsoak:
	; a: Switch off SSR
	; b: Switch on soaktimer
	
;- SOAK RAMP -;


soakramploop:  
	
	lcall readtemperature
	clr c  
	mov a, tempsoak
	subb a, #15 ; jumps to pwm 40 degrees below required temperature
	subb a, Result
	jnc soakramploop
	
;	clr SSRpin ; Step 2a: switch off SSR
	
pwmloop:
	setb SSRpin
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	clr SSRpin
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	lcall readtemperature
	lcall soakcompletecheck
	
	ljmp pwmloop


	; if Result > tempsoak, jump to soakmesa - else, jump back and switch on oven again


soakcompletecheck:
	
	clr c 
	mov a, tempsoak 
	subb a, Result
	jc soakmesapreloop
	
	ret
	
;- SOAK MESA -;


soakmesapreloop:


	mov statecounter, #2
	setb statechangeflag


	Set_Cursor(1,1)
	Send_Constant_String(#EnteringSoak)


soakmesaloop: ; 
	lcall readtemperature ; gets temperature once a second - this is functionally a one second wait 
	mov a, soaktimer
	add a, #0x01
	mov soaktimer, a; increments timer by one
	cjne a, timesoak, soakmesaloop1 ;  Check 2.1 - soak time


	ljmp theoatmeal
	
	; Check 2.2 - soak temperature +-3 (Result +-3)
	
soakmesaloop1:
	; Result > tempsoak + 3
	
	clr c 
	mov a, tempsoak 
	add a, #0x01 ; 3 degree tolerance
	subb a, Result
	jnc soakmesaloop2 
	
	clr SSRpin
	lcall soakcontrolroutine1
	
soakmesaloop2:	
	; Result < tempsoak - 3 == Result + 3 < tempsoak
	clr c
	mov a, Result
	add a, #0x01 ; 3 degree tolerance
	subb a, tempsoak
	jnc soakmesaloop 
	
	setb SSRpin
	lcall soakcontrolroutine2
			
sjmp soakmesaloop
	
; SOAKCONTROLROUTINE1 ;


soakcontrolroutine1: 


	lcall readtemperature ; reads temperature once per second
	mov a, soaktimer
	add a, #0x01
	mov soaktimer, a; increments timer by one
	cjne a, timesoak, soakcontrolroutinecheck1 ;  Check 2.1 - soak time
	
	ljmp theoatmeal


; Result > tempsoak + 2 control loop
; oven starts in off state in this loop
; while Result > tempsoak + 2: stay here
	; return 
	
soakcontrolroutinecheck1:


	clr c 
	mov a, tempsoak
	add a, #0x01 ; 2 degree tolerance
	subb a, Result
	jc soakcontrolroutine1
	
	ret ; if Result drops below tempsoak - 2, return to original loop


; SOAKCONTROLROUTINE2 ;


soakcontrolroutine2: 


	lcall readtemperature ; reads temperature once per second
	mov a, soaktimer
	add a, #0x01
	mov soaktimer, a; increments timer by one
	cjne a, timesoak, soakcontrolroutinecheck2 ;  Check 2.1 - soak time
	
	ljmp theoatmeal


; Result < tempsoak + 2 control loop
; oven starts in off state in this loop
; pseudocode:
; while Result > tempsoak + 2: stay here
	; return 
	
soakcontrolroutinecheck2:


	clr c
	mov a, Result
	add a, #0x01 ; 2 degree tolerance
	subb a, tempsoak
	jc soakcontrolroutine2
	
	ret


theoatmeal: 
setb SSRpin


;- REFLOWRAMP -;


reflowramploop: ; 
	
	lcall readtemperature
	clr c 
	mov a, tempreflow
	subb a, #15 ; jumps to pwm 40 degrees below required temperature
	subb a, Result
	jnc reflowramploop
	
	ljmp pwmloop2
	
	;setb P2.5
	
;	clr SSRpin ; Step 2a: switch off SSR


pwmloop2:
	setb SSRpin
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	clr SSRpin
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature
	lcall reflowcompletecheck
	lcall readtemperature ; if Result > tempsoak, jump to soakmesa - else, jump back and switch on oven again
	
	ljmp pwmloop2
	
reflowcompletecheck:


	clr c 
	mov a, tempreflow
	subb a, Result
	jc reflowmesalooppre
	
	ret
		
;- REFLOWMESA -;


reflowmesalooppre:  


	mov statecounter, #3
	setb statechangeflag
	
	Set_Cursor(1,1)
	Send_Constant_String(#EnteringReflow)


reflowmesaloop:
	lcall readtemperature ; gets temperature once a second - this is functionally a one second wait 
	mov a, reflowtimer
	add a, #0x01
	mov reflowtimer, a; increments timer by one
	cjne a, timereflow, reflowmesaloop1 ;  Check 2.1 - reflow time


	ljmp cool
	
	; Check 2.2 - reflow temperature +-3 (Result +-3)
	
reflowmesaloop1:
	; Result > tempreflow + 3
	clr c 
	mov a, tempreflow 
	add a, #0x01 ; 3 degree tolerance
	subb a, Result
	jnc reflowmesaloop2 
	
	clr SSRpin
	lcall reflowcontrolroutine1
	
reflowmesaloop2:	
	; Result < tempreflow - 3 == Result + 3 < tempreflow
	clr c
	mov a, Result
	add a, #0x01 ; 3 degree tolerance
	subb a, tempreflow
	jnc reflowmesaloop 
	
	setb SSRpin
	lcall reflowcontrolroutine2
			
sjmp reflowmesaloop
	
; REFLOWCONTROLROUTINE1 ;


reflowcontrolroutine1: 


	lcall readtemperature ; reads temperature once per second
	mov a, reflowtimer
	add a, #0x01
	mov reflowtimer, a; increments timer by one
	cjne a, timereflow, reflowcontrolroutinecheck1 ;  Check 2.1 - reflow time
	
	ljmp cool


; Result > tempreflow + 2 control loop
; oven starts in off state in this loop
; while Result > tempreflow + 2: stay here
	; return 
	
reflowcontrolroutinecheck1:


	clr c 
	mov a, tempreflow
	add a, #0x01 ; 2 degree tolerance
	subb a, Result
	jc reflowcontrolroutine1
	
	ret ; if Result drops below tempreflow - 2, return to original loop


; REFLOWCONTROLROUTINE2 ;


reflowcontrolroutine2: 


	lcall readtemperature ; reads temperature once per second
	mov a, reflowtimer
	add a, #0x01
	mov reflowtimer, a; increments timer by one
	cjne a, timereflow, reflowcontrolroutinecheck2 ;  Check 2.1 - reflow time


	ljmp cool


; Result < tempreflow + 2 control loop
; oven starts in off state in this loop
; while Result > tempreflow + 2: stay here
	; return 


reflowcontrolroutinecheck2:


	clr c
	mov a, Result
	add a, #0x01 ; 2 degree tolerance
	subb a, tempreflow
	jc reflowcontrolroutine2
	
	ret


cool: 
clr SSRpin
mov statecounter, #4


setb statechangeflag


Set_Cursor(1,1)
Send_Constant_String(#ReflowComplete)


lcall readtemperature


;--------------;
; TEXT MESSAGE ;
;--------------;


; Sends a 01 flag that indicates that a text message should be sent


mov textvar, #1


mov x, textvar
mov x+1, #0
mov x+2, #0
mov x+3, #0
	
lcall hex2bcd


lcall SendTemp


lcall Wait1s
lcall Wait1s


; COOL DOWN 


cooldown:
lcall readtemperature


clr c
mov a, Result
subb a, #50
jnc cooldown 


lcall Wait1s
lcall Wait1s
lcall Wait1s
lcall Wait1s


mov instruction, #2
mov statecounter, #5
lcall speak
mov soakramptimer, #0


Set_Cursor(1,1)
Send_Constant_String(#SolderingComplete)


done:
clr SSRpin
sjmp done


;-----------------;
; READTEMPERATURE ;
;-----------------;


; Functionality:
; 	1. Reads room temperature
;	2. Reads relative oven temperature
;	3. Calculates the final oven temperature using an average function, and stores it in variable 'Result'
;	4. Sends a signal to the SPEAK function to 'speak' the temperature every 5 seconds
;	5. 60 second abort check: if temperature < 50 Celsius after the oven has heated for 60 seconds, ABORT (shut down the oven)
	
readtemperature:
    clr dog ; variable initalization, flag used for read temp
    mov a, soakramptimer ; soakramptimer stores time elapsed since the start of the reflow cycle 
    add a, #0x01
    mov soakramptimer, a
    
    mov a, time
    add a, #0x01
    mov time, a
    
    mov x, time
    mov x+1, #0
    mov x+2, #0
    mov x+3, #0
   
   	lcall hex2bcd
    
    Set_Cursor(2,1)
    Display_BCD(bcd+1)
    Display_BCD(bcd) ; displays continuous timer
    
    mov instruction, #0
       	
check_inputs:
 
  lcall get_thermostat
  lcall oven_temp
	
  mov x, sheep ; reference temperature
  mov x+1, #0
  mov x+2, #0
  mov x+3, #0
    
  mov y, cat ; oven temperature
  mov y+1, #0
  mov y+2, #0
  mov y+3, #0
    
  lcall add32  
  mov Result, x ; final oven temperature value stored in 'Result'
  mov Result+1, x+1
  
  lcall hex2bcd
  
  Set_Cursor(2,12)
  Display_BCD(bcd+1)
  Display_BCD(bcd)
       
  lcall SendTemp
  
;----------------------------;
;	SAFETY CRITICAL:		 ;
; 	60 SECOND ABORT CHECK    ;


  mov a, time
  cjne a, #60, continuereadtemp
  
  clr c
  mov a, Result
  subb a, #51
  jnc continuereadtemp
  
  ljmp done 
  
; CHECK ENDS HERE ;
;-----------------;


; The following code sends the 'Result' value, as well as its hundreds, tens and units values to the 'SPEAK' function every 5 seconds


continuereadtemp: 
 
  mov a, Result
  mov b, #100
  div ab 
  mov hundredsresult, a
  	
  mov a, b
  mov b, #10
  div ab
  mov tensresult, a
  	
  mov unitsresult, b
  	
  	mov a, soakramptimer
  	mov b, #5
  	div ab
  	mov a, b
  	
  cjne a, #0, returnsequence
  jb statechangeflag, returnstatesequence
  	
  	mov hundredsj, hundredsresult
  	mov tensj, tensresult
  	mov unitsj, unitsresult
  	
  	mov temp, Result
  	
    mov instruction, #1	
  	
returnsequence: 


	lcall speak


    lcall Wait1s
    lcall Wait1s
    
 	ret
 	
returnstatesequence:


	mov instruction, #2
	clr statechangeflag
	lcall speak
	
	lcall Wait1s
	lcall Wait1s
	
	ret
    
; get_thermostat: gets the room temperature value from an LM335 temperature sensor to use as a reference 


get_thermostat:
    mov x+0, AD0DAT0
    mov x+1, #0
    mov x+2, #0
    mov x+3, #0
		
	; Convert to temperature (C)
	Load_Y(330) ; Vref is 3.3V
	lcall mul32
	Load_Y(255)
	lcall div32
	Load_Y(273)
	lcall sub32
	
	mov cat, x
	 	
  	ret
  	
; oven_temp: gets 255 oven temperature values and averages them (average = sum/255)
	
oven_temp: 
	Load_x(0)
	mov x+0, AD0DAT3
    mov x+1, #0
    mov x+2, #0
    mov x+3, #0
	mov R7, #255
    lcall Wait10us
acc_temp:
  	mov y+0, AD0DAT3
    mov y+1, #0
    mov y+2, #0
    mov y+3, #0
    
  	lcall add32
    lcall Wait10us
	djnz R7, acc_temp
	
	Load_y(255)
	lcall div32
 	
 	Load_Y(1000000)
 	lcall mul32
 	
 	Load_Y(41)
 	lcall div32
 	
;R2 value
    Load_Y(330)
	lcall mul32
	
 	Load_Y(80)
 	lcall div32
 	
;R1 value  
   	Load_Y(100000)
    lcall div32
 
    mov sheep, x
 
	ret 
	
;-------;
; SPEAK ;
;-------;


; Inputs:
; 1. instruction: 0 = do nothing, 1 = read temperature, 2 = state transition
; 2. statecounter: indicates which state transition is currently occurring - only used when instruction = 2
; 3. temp, hundredsj, tensj, unitsj: the temperature of the oven, as well as its hundreds, tens and units value to be read out, received
;	 every 5 seconds


; Outputs: 
; - If instruction = 0, nothing. 
; - If instruction = 1, reads out the current oven temperature.
; - If instruction = 2, reads out the current state message.
	
speak:
	
	mov a, instruction
	cjne a, #0, start_routine_1
	
	mov a, tmp_count
	cjne a, #0, check_tens
	ret  
	
start_routine_1:
	cjne a, #1, start_routine_2
	mov tmp_count, #0
	ljmp check_tens
	
start_routine_2:
	mov a, statecounter
	add a, #28
	mov b, #3
	mul ab
	
	mov speak_num, a
	ljmp play_temp	
	
check_tens:
	clr c
	mov a, tensj 
	subb a, #2 
	jnc check_tmp_counter_2 ; if tens < 2, there will be a carry, so jump


define_last:
	
	mov a, temp
	mov b, #100
	div ab
	mov last, b  ;last = temp % 100
	
check_tmp_counter_1: ;tens < 2
	mov a, tmp_count


	cjne a, #1, check_hundreds ;if temp_count is 1, then speak last
	
	mov tmp_count, #0
	mov a, last
	mov b, #3
	mul ab
	mov speak_num, a
	
	ljmp play_temp
		
check_hundreds: 
	mov a, hundredsj
	cjne a, #0, G1
	
	mov tmp_count, #0 ;no hundreds, so just play last
	mov a, last
	mov b, #3
	mul ab
	mov speak_num, a


	ljmp play_temp
	
G1:	cjne a, #1, G2
	mov speak_num, #102 ;say one hundred
	
	mov tmp_count, #1	
	ljmp play_temp
	
G2: mov speak_num, #105 ;say two hundreds
	mov tmp_count, #1


	ljmp play_temp
	
	
check_tmp_counter_2: ;tens > 2
	
	mov a, tmp_count
	
	cjne a, #0, C1
	mov tmp_count, #1 ;say hundreds
	mov a, hundredsj
	mov b, #3
	mul ab
	
	mov speak_num, a	
	ljmp play_temp
	
C1: cjne a, #1, C2
	mov tmp_count, #2 ;say tens
	mov a, tensj
	add a, #18
	mov b, #3
	mul ab		;index = 3(18 + tens)
	mov speak_num, a
	ljmp play_temp
	
C2:	mov tmp_count, #0
	mov a, unitsj ;say units
	mov b, #3
	mul ab
	mov speak_num, a
	ljmp play_temp
		
play_temp:	


	mov instruction, #0


	clr TMOD20 ; Stop the CCU from playing previous request
	setb FLASH_CE
	
	clr FLASH_CE ; Enable SPI Flash
	mov a, #READ_BYTES
	lcall Send_SPI
	
	mov dptr, #sound_index


	mov a, speak_num
	movc a, @dptr+a
	lcall Send_SPI
	inc dptr
	
	mov a, speak_num
	movc a, @dptr+a
	lcall Send_SPI
	inc dptr
	
	mov a, speak_num
	movc a, @dptr+a
	lcall Send_SPI
	
	mov dptr, #size_length
	
	mov a, speak_num
	movc a, @dptr+a
	mov w+2, a
	inc dptr
	
	mov a, speak_num
	movc a, @dptr+a
	mov w+1, a
	inc dptr
	
	mov a, speak_num
	movc a, @dptr+a
	mov w+0, a	


	mov a, #0x00 
	lcall Send_SPI
	
	setb TMOD20	
		
	ret	
	
end
